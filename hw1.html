<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW1</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>WebGL Test</h2>
  <p>Edit vertex and fragment shaders on the left, and you can see the result on the right instantly. <br>
    Please copy your edits to the source code if you want to save them, as the playground doesn't save them to the file.
  </p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vsEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fsEditor"></textarea>
      </div>
    </div>

    <div>
      <canvas id="glcanvas" width="600" height="600"></canvas>
    </div>
  </div>

  <!-- Vertex Shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
  in vec3 aPosition;
  in vec3 aColor;

  uniform float uTime; //time in sec
  uniform mat3 uRotation; //rotation
  uniform vec3 uTranslation; //translation
  out vec3 vColor;

  void main() {
    gl_Position = vec4((uRotation * aPosition), 1.0);
    vColor = aColor;
  }
  </script>

  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
  precision mediump float;
  in vec3 vColor;
  uniform float uTime; //time in sec
  //uniform mat3 uRandColors;

  out vec4 fragColor;

  void main() {
    fragColor = vec4(vColor, 1.0);
  }
  </script>

  <script src="triangle.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }


    // --- WebGL init ---
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    const vsEditor = document.getElementById("vsEditor");
    const fsEditor = document.getElementById("fsEditor");
    vsEditor.value = document.getElementById("vertex-shader").textContent;
    fsEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, timeLoc, rotationLoc, translationLoc, randColorLoc;
    let posBuffer, colorBuffer;
    var colors = getRandomRgb(positions.length);

    // --- Buffers ---
    function initBuffers() {
      posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    }

    initBuffers();

    function initShaderProgram() {
      try {
        program = createProgram(gl, vsEditor.value, fsEditor.value);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        rotationLoc = gl.getUniformLocation(program, "uRotation");
        translationLoc = gl.getUniformLocation(program, "uTranslation");
        randColorLoc = gl.getUniformLocation(program, "uRandColors");
      } catch (e) { console.error(e); }
    }

    function getRandomRgb(length) {
      let result = new Float32Array(length);
      for (i = 0; i < length; i++) {
        result[i] = Math.random();
      }
      return result;
    }

    function interpolateColors(prevColors, targetColors, lastColorChange, colorChangeInterval) {
      const t = lastColorChange / colorChangeInterval;
      const arraySize = prevColors.length;
      const result = new Float32Array(arraySize); // Assuming 3x3 matrix = 9 elements

      for (let i = 0; i < arraySize; i++) {
        result[i] = (1 - t) * prevColors[i] + t * targetColors[i];
      }

      return result;
    }


    initShaderProgram();

    //hot compile when any input in the playground text area
    vsEditor.onkeyup = initShaderProgram;
    fsEditor.onkeyup = initShaderProgram;

    let startTime = Date.now();
    let deltaTime = 0.0;
    let frameTime = 0.0;
    let lastColorChange = 0.0;
    let colorChangeInterval = 2.0;
    let prevColors = colors;
    let targetColors = getRandomRgb(prevColors.length);

    function render() {
      //clear the canvas
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      // Position buffer binding
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      // Color buffer binding
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

      //delta time in ms
      frameTime = Date.now() - (deltaTime + startTime); //time since last update
      deltaTime = Date.now() - startTime;
      lastColorChange += (frameTime / 1000.0);
      //set time in seconds
      gl.uniform1f(timeLoc, deltaTime / 1000.0);

      //Rotation
      let rotationSpeed = 0.1;
      let angleInDegrees = deltaTime * rotationSpeed;
      let angleInRadians = angleInDegrees * Math.PI / 180;

      // Calculate sine and cosine
      let cos = Math.cos(angleInRadians);
      let sin = Math.sin(angleInRadians);

      // Create the 4x4 rotation matrix (column-major order for webgl)
      let rotationMatrix = [
        cos, sin, 0.0,
        -sin, cos, 0.0,
        0.0, 0.0, 1.0,
      ];
      gl.uniformMatrix3fv(rotationLoc, false, rotationMatrix);

      //translation vals
      let translationSpeed = 0.1;
      let tx = deltaTime * translationSpeed;

      //translation matrix
      let translationMatrix = [
        1, 0, 0,
        0, 1, 0,
        tx, 0, 1
      ];
      //todo: redo the translation code
      //gl.uniformVec3fv(translationLoc, translationMatrix);


      //random colors
      let colorChangeSpeed = 0.1;
      if (lastColorChange >= colorChangeInterval) {
        lastColorChange -= colorChangeInterval;
        prevColors = targetColors;
        targetColors = getRandomRgb(colors.length);
      }
      let currentColors = interpolateColors(prevColors, targetColors, lastColorChange, colorChangeInterval);
      colors = currentColors;
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

      //gl.uniformMatrix3fv(randColorLoc, false, currentColors);

      // Draw content
      gl.drawArrays(gl.TRIANGLES, 0, (colors.length / 3));
    }

    // Initialize when page loads
    window.onload = function () {
      setInterval(render, 30);
    };
  </script>
</body>

</html>